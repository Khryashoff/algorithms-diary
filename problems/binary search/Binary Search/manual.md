## Binary Search - Leetcode 704. Easy

Учитывая массив целых чисел, nums который отсортирован в порядке возрастания, и целое число target, напишите функцию для поиска target в nums. Если target существует, то верните его индекс. В противном случае верните -1.

Вы должны написать алгоритм со O(log n) сложностью во время выполнения.

**Пример 1:**
```bash
Input: nums = [-1,0,3,5,9,12], target = 9
Output: 4
```
**Пример 2:**
```bash
Input: nums = [-1,0,3,5,9,12], target = 2
Output: -1
```

**Решение**
```python
class Solution:
    def good(self, val: int, target: int):
        return val <= target


    def search(self, nums: List[int], target: int) -> int:
        left = 0
        right = len(nums)
        
        while right - left > 1:
            current = (left + right) // 2
            if self.good(nums[current], target):
                left = current
            else:
                right = current 
        return left if nums[left] == target else - 1
```

**Оценка по времени:** O(log n)  
Осуществляется бинарный поиск по исходному массиву, т.е. из проверки исключается большая часть значений.

**Оценка по памяти:** O(1)  
Создаются две переменных для хранения левого и правого индекса.

**Объяснение решения**  
1. В основной функции search создаются две переменных для хранения текущего положения правого и левого индексов.
2. Запускается цикл, который работает, пока разность правого и левого индексов больше единицы.
3. Создается проверочное выражение для получения среднего индекса путем деления суммы текущих индексов на два // 2.
4. Запускается дополнительная функция good, которая сравнивает значения и возвращает True или False. 
Если значение nums с полученным средним индексом меньше или равно целевому числу, то указатель левого индекса принимает значение среднего индекса.
5. Иначе, правый индекс принимает значение среднего индекса.
6. Возвращается левый индекс, если значение nums с левым индексом равно целевому числу, иначе возвращает минус один -1.

**Зачем выделять good в отдельную функцию?**  
Абстракция: использование функции good позволяет вынести логику сравнения в отдельную функцию, что делает основной цикл более понятным и легко расширяемым. Например, если нужно будет изменить логику проверки (например, добавить другой тип сравнения), достаточно изменить только функцию good, а не переписывать основной цикл.
