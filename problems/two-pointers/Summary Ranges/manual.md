## Summary Ranges - Leetcode 228. Easy

Вам будет предоставлен отсортированный уникальный массив целых чисел nums.
Диапазон [a,b] - это набор всех целых чисел из a до b (включительно).

Возврат наименьший из отсортированных список диапазонов, которые в точности охватывают все числа в массиве. То есть каждый элемент из nums покрывается ровно одним из диапазонов, и в нем нет целого числа x такого, что x находится в одном из диапазонов, но не в nums.

Каждый диапазон [a,b] в списке должен быть выведен как:

"a->b" если a != b
"a" если a == b

**Пример 1:**
```bash
Input: nums = [0,1,2,4,5,7]
Output: ["0->2","4->5","7"]
```
**Пример 2:**
```bash
Input: nums = [0,2,3,4,6,8,9]
Output: ["0","2->4","6","8->9"]
```

**Решение 1** - по времени 32 мс (лучше 74,23%), память 16.57 MB (лучше 28,73%)
```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        indLeft = 0
        indRight = 0
        result = []
        
        while indLeft < len(nums):
            nextIdx = nums[indRight] + 1
            if indRight + 1 < len(nums) and nextIdx == nums[indRight + 1]:
                indRight += 1
                continue
            else:
                if indLeft != indRight:
                    result.append(f'{nums[indLeft]}->{nums[indRight]}')
                else:
                    result.append(f'{nums[indRight]}')
            indRight += 1
            indLeft = indRight
        return result
```

**Решение 2** - по времени 34 мс (лучше 59,93%), память 16.55 MB (лучше 29,61%)
```python
class Solution:
    def summaryRanges(self, nums: List[int]) -> List[str]:
        left = 0
        right = 0
        result = []
        while left < len(nums):
            while right + 1 < len(nums) and nums[right] + 1 == nums[right + 1]:
                right += 1
            if right != left:
                result.append(f'{nums[left]}->{nums[right]}')
            else:
                result.append(f'{nums[left]}')
            left = right + 1
            right = right + 1
        return result
```

**Оценка по времени:** O(n)  
Осуществляется один проход по исходному массиву nums.

**Оценка по памяти:** O(1)  
Объявляются две переменные для хранения текущих индексов. Сложность O(1) будет если не учитывать результирующий массив, так как в худшем случае, он может быть равен исходному массиву, тогда оценка по памяти будет O(n).

**Объяснение решения**  
1. Инициализируются две переменные для хранения левого индекса (начало периода) и правого индекса (конца периода), а также результирующий массив. 
2. Запускается цикл, который будет работать пока верно условие: левый индекс меньше длины массива nums.
3. Производится расчёт следующего числа nextIdx, который является суммой текущего значения правого индекса плюс единица +1.
4. Если значение левого индекса плюс единица +1 меньше длины массива nums и следующее число nextIdx равно значению числа с правым индексом плюс единица +1, то к значению правого индекса прибавляется едница +1 и цикл запускается заново, благодаря continue.
5. Иначе, если левый индекс не равен правому индексу, то в конец результирующего массива добавляется f-строка, содержащая текущее значение nums с левым индексом "->" текущее значение nums с правым индексом. 
6. Иначе в конец результирующего массива добавляется f-строка с текущим значением nums с правым индексом.
7. После проверок к значению правого индекса прибавляется единица +1, а левому индексу присваивается текущее значение правого индекса.
8. Возвращается результирующий массив.
