## Container With Most Water - Leetcode 11. Medium

Вам будет предоставлен массив целых чисел height длины n. Здесь n нарисованы вертикальные линии таким образом, что двумя конечными точками ith линии являются (i, 0) и (i, height[i]).

Найдите две линии, которые вместе с осью x образуют контейнер таким образом, чтобы в контейнере было больше всего воды.
Возвращайте максимальное количество воды, которое может вместить емкость.

Обратите внимание, что нельзя наклонять емкость.

**Пример 1:**
```bash
Input: height = [1,8,6,2,5,4,8,3,7]
Output: 49
```
**Пример 2:**
```bash
Input: height = [1,1]
Output: 1
```

**Решение 1** - Время 493 мс (лучше ~94,61%), память 22.20 MB (лучше ~56,96%)
```python
class Solution(object):
    def maxArea(self, height):
        left = 0
        right = len(height) - 1
        result = 0
        
        while left < right:
            if height[left] < height[right]:
                volume = height[left] * (right - left)
                left += 1
            # Улучшение 1. При наличии этого блока - время 493 мс (лучше ~94,61%), память 22.20 MB (лучше ~56,96%)
            # elif height[left] > height[right]:
            #     volume = height[right] * (right - left)
            #     right -= 1
            else:
                volume = height[right] * (right - left)
                right -= 1
            
            # Улучшение 2. При наличии этого блока - время 466 мс (лучше ~98,55%), память 22.18 MB (лучше ~56,96%)
            # if volume > result:
            #     result = volume
            # Золотая середина - время 498 мс (лучше ~92,97%), память 22.06 MB (лучше ~85,22%)
            result = max(result, volume)
        return result
```

**Решение 2** - Время 531 мс (лучше ~56,74%), память 22.04 MB (лучше ~85,22%)
```python
class Solution(object):
    def maxArea(self, height):
        left = 0
        right = len(height) - 1
        result_area = 0
        while left < right:
            curr_area = min(height[left], height[right]) * (right - left)
            result_area = max(result_area, curr_area)
            if height[left] < height[right]:
                left += 1
            else:
                right -= 1
        return result_area
```

**Оценка по времени:** O(n)  
Осуществляется один проход по исходному массиву.

**Оценка по памяти:** O(1)  
Создаются три переменных - два указателя, для хранения левого и правого индексов и одна переменная для хранения результата. 

**Объяснение решения**  
1. Инициализируются два указателя: левый - стартует от начала массива, правый - стартует с конца массива. Также создается переменная для хранения результата.
2. Запускается цикл, который работает, пока верно условие, что левый указатель меньше или равен правому.
3. Если значение числа с индексом left меньше, значения числа с индексом right, то объём контейнера будет равен произведению: числа с индексом left на разность значений правого и левого индексов. При этом левый указатель двигается вперед. 
4. Иначе, (если значение left больше или они равны) объём контейнера будет равен произведению: числа с индексом right на разность значений правого и левого индексов. При этом правый указатель двигается вперед. 
5. В результирующую переменную будет присвоено максимальное значение между текущим результатом и текущим объёмом. В конце возвращается результат. 
