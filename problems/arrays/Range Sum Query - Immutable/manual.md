## Range Sum Query - Immutable - Leetcode 303. Easy

Учитывая массив целых чисел nums, обработайте несколько запросов следующего типа:  
Вычислите сумму элементов nums между индексами left и right включительно где left <= right.

Реализовать NumArray класс:  
NumArray(int[] nums) Инициализирует объект целочисленным массивом nums.
int sumRange(int left, int right) Возвращает сумму элементов nums между индексами left и right включительно (т.е. nums[left] + nums[left + 1] + ... + nums[right]).

**Пример 1:**
```bash
Input: ["NumArray", "sumRange", "sumRange", "sumRange"] [[[-2, 0, 3, -5, 2, -1]], [0, 2], [2, 5], [0, 5]]
Output: [null, 1, -1, -3]
```


**Решение 1** - чуть менее эффективно по памяти (~15.54 Mb, превосходит 44,99%)
```python
class NumArray(object):

    def __init__(self, nums):
        prefix_arr = [0]
        for i in range(0, len(nums)): 
            prefix_arr.append(prefix_arr[i] + nums[i])
        self.prefix_arr = prefix_arr
        

    def sumRange(self, left, right):
        return self.prefix_arr[right + 1] - self.prefix_arr[left]
```

**Решение 2** - эффективнее по памяти (~15.20 Mb, превосходит 94,99%)
```python
class NumArray(object):

    def __init__(self, nums):
        prefix_arr = [0]
        for i in nums: 
            prefix_arr.append(prefix_arr[-1] + i)
        self.prefix_arr = prefix_arr
        

    def sumRange(self, left, right):
        return self.prefix_arr[right+1] - self.prefix_arr[left]
```

*Для ининициализации*  
**Оценка по времени:** O(n)  
Осуществляется один проход по исходному массиву.  
**Оценка по памяти:** O(n)  
Создается дополнительный массив prefix_arr, длинной n+1.

*Для запросов*  
**Оценка по времени:** O(1)  
Выполняется за константное время.  
**Оценка по памяти:** O(1)  
Дополнительная память не аллоцируется.

**Объяснение решения**  
1. Инициализируется префиксный массив для хранения суммированных значений исходного массива.
2. **Решение 1** Запускается цикл, работающий с диапазоном индексов от 0 до длинны списка nums. В конец префиксного массива добавляется элемент равный сумме значений префиксного массива и списка nums с индексами i. 
3. **Решение 2** Запускается цикл, который перебирает список nums. В конец префиксного массива добавляется элемент равный сумме последнего элемента префиксного массива и текущего значения i.
4. Полученный префиксный массив сохраняется в атрибуте объекта. 
5. Возвращается результат - разность между правой границей +1 (т.к. в префиксном массиве, в начале добавлен 0) и левой границей, что в итоге даст включительно сумму элементов от левой до правой границы.
