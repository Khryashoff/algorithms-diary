## Find Pivot Index - Leetcode 724. Easy

Учитывая массив целых чисел nums, вычислите сводный индекс этого массива.

Сводный индекс - это индекс, в котором сумма всех чисел, строго расположенных слева от индекса, равна сумме всех чисел, строго расположенных справа от индекса.
Если индекс находится на левом краю массива, то сумма слева равна 0 потому что слева нет элементов. Это также относится к правому краю массива.

Верните самый левый сводный индекс. Если такого индекса не существует, верните -1.

**Пример 1:**
```bash
Input: nums = [1,7,3,6,5,6]
Output: 3
```

**Пример 2:**
```bash
Input: nums = [1,2,3]
Output: -1
```
**Пример 3:**
```bash
Input: nums = [2,1,-1]
Output: 0
```

**Пример 4:**
```bash
Input: nums = [-1,-1,-1,-1,-1,0]
Output: 2
```
 

**Решение 1** - Немного хуже по памяти (~12.91 MB, превосходит 17,98%)
```python
class Solution(object):
    def pivotIndex(self, nums):
        prefix_sum = 0
        right_sum = 0
        left_sum = 0 
        
        for i in nums:
            prefix_sum += i
        
        for i in range(0, len(nums)):
            right_sum = prefix_sum - left_sum - nums[i]
            if left_sum == right_sum:
                return i
            else:
                left_sum += nums[i]
        return -1
```

**Решение 2** - эффективнее по памяти (~12.71 Mb, превосходит 65,26%) и выглядит более эстетично 
```python
class Solution(object):
    def pivotIndex(self, nums):
        prefix_sum = sum(nums)
        left_sum = 0 
        
        for i, num in enumerate(nums):
            right_sum = prefix_sum - left_sum - num
            if left_sum == right_sum:
                return i
            left_sum += num
        return -1
```

**Оценка по времени:** O(n)  
Осуществляется один проход по исходному массиву.  
**Оценка по памяти:** O(1)  
Создается несколько переменных хранящих значение, дополнительная память не аллоцируется.

**Объяснение решения**  
1. Инициализируется несколько переменных для хранения сумм значений.
2. **Решение 1** Запускается цикл, который суммирует значения из массива nums. Затем запускается цикл, работающий с диапазоном индексов от 0 до длины массива nums. 
Создается выражение, для получения текущего значения суммы чисел с правой стороны. 
3. Если левая сумма равна правой сумме, то возвращается индекс текущего элемента. Иначе к левой сумме прибавляется значение с текущим индексом. 
В противном случае, если опорный индекс не находится, то возвращается -1.
4. **Решение 2** Значения массива nums суммируются при помощи метода sum() в переменной. Затем запускается цикл, который получает индекс и значение из массива nums.
Создается выражение, для получения текущего значения суммы чисел с правой стороны. 
5. Если левая сумма равна правой сумме, то возвращается индекс текущего элемента. Если условие не срабатывает к левой сумме прибавляется значение с текущим индексом. В противном случае, если опорный индекс не находится, то возвращается -1.
